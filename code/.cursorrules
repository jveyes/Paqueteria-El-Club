# ========================================
# PAQUETES EL CLUB v3.0 - Cursor Rules
# ========================================

## üéØ **OBJETIVO DEL PROYECTO**
Sistema de gesti√≥n de paqueter√≠a con tarifas autom√°ticas, notificaciones multicanal y dashboard administrativo. 
Enfoque en modularidad, escalabilidad y mantenibilidad del c√≥digo.

## üèóÔ∏è **ARQUITECTURA Y PATRONES**

### **Principios de Dise√±o**
- **Separaci√≥n de Responsabilidades**: Cada m√≥dulo tiene una responsabilidad espec√≠fica
- **Inversi√≥n de Dependencias**: Los routers dependen de servicios, no de modelos directamente
- **Configuraci√≥n Centralizada**: Todas las configuraciones en `src/config.py`
- **Manejo de Errores Unificado**: Excepciones personalizadas en `src/utils/exceptions.py`
- **Validaciones Centralizadas**: Funciones de validaci√≥n en `src/utils/validators.py`

### **Estructura de Capas**
1. **Routers** (`src/routers/`): Manejo de HTTP requests/responses
2. **Servicios** (`src/services/`): L√≥gica de negocio
3. **Modelos** (`src/models/`): Entidades de base de datos
4. **Esquemas** (`src/schemas/`): Validaci√≥n de datos con Pydantic
5. **Utilidades** (`src/utils/`): Funciones helper y validaciones
6. **Configuraci√≥n** (`src/config.py`): Variables de entorno centralizadas

## üêç **PYTHON / FASTAPI**

### **Convenciones de C√≥digo**
- **PEP 8**: Seguir est√°ndares de Python
- **Type Hints**: Usar siempre type hints en funciones y m√©todos
- **Docstrings**: Documentar todas las funciones p√∫blicas
- **Nombres Descriptivos**: Variables y funciones con nombres claros
- **Imports Organizados**: Agrupar imports por tipo (stdlib, third-party, local)

### **FastAPI Espec√≠fico**
- **Dependency Injection**: Usar `Depends()` para inyecci√≥n de dependencias
- **Response Models**: Definir siempre modelos de respuesta con Pydantic
- **Status Codes**: Usar c√≥digos HTTP apropiados
- **Async/Await**: Usar async para operaciones I/O
- **Exception Handling**: Manejar excepciones con handlers personalizados

### **Ejemplo de Router**
```python
@router.post("/", response_model=PackageResponse)
async def create_package(
    package_data: PackageCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
) -> PackageResponse:
    """Crear nuevo paquete con validaciones y notificaciones"""
    package_service = PackageService(db)
    return package_service.create_package(package_data)
```

## üóÑÔ∏è **SQLALCHEMY / BASE DE DATOS**

### **Convenciones de Modelos**
- **Herencia de BaseModel**: Todos los modelos heredan de `BaseModel`
- **Herencia de Base**: Todos los modelos DEBEN heredar tambi√©n de `Base` para SQLAlchemy
- **Relaciones Expl√≠citas**: Definir todas las relaciones con `relationship()`
- **√çndices**: Crear √≠ndices para campos de b√∫squeda frecuente
- **Constraints**: Usar constraints de base de datos apropiados
- **Timestamps**: Incluir `created_at` y `updated_at` autom√°ticamente

### **Configuraci√≥n de Modelos**
- **Estructura correcta**: `class ModelName(BaseModel, Base):`
- **Timestamps autom√°ticos**: Usar `default=datetime.utcnow` para `created_at`
- **Timestamps de actualizaci√≥n**: Usar `onupdate=datetime.utcnow` para `updated_at`
- **Verificar herencia**: Confirmar que todos los modelos heredan de ambas clases base

### **Ejemplo de Modelo**
```python
class Package(BaseModel, Base):
    __tablename__ = "packages"
    
    tracking_number = Column(String(50), unique=True, nullable=False, index=True)
    status = Column(Enum(PackageStatus), default=PackageStatus.ANUNCIADO)
    
    # Relaciones
    notifications = relationship("Notification", back_populates="package")
    
    def __repr__(self):
        return f"<Package {self.tracking_number} - {self.status}>"
```

### **Migrations (Alembic)**
- **Nombres Descriptivos**: Usar nombres que describan el cambio
- **Rollback Seguro**: Siempre implementar `downgrade()`
- **Datos de Prueba**: Incluir datos de prueba en migraciones cuando sea apropiado

### **Verificaci√≥n de Migraciones**
- **SIEMPRE verificar estado de migraciones antes de diagnosticar problemas de base de datos**
- **Comprobar que las migraciones est√©n aplicadas**: `alembic current` debe mostrar la √∫ltima migraci√≥n
- **Verificar existencia de tablas**: Confirmar que las tablas existen antes de diagnosticar errores de modelo
- **Aplicar migraciones pendientes**: Ejecutar `alembic upgrade head` si hay migraciones sin aplicar
- **Verificar estructura de tablas**: Usar `\dt` y `\d table_name` para confirmar estructura correcta

### **Diagn√≥stico de Base de Datos**
- **Orden de verificaci√≥n**:
  1. Estado de migraciones (`alembic current`)
  2. Existencia de tablas (`\dt`)
  3. Estructura de tablas (`\d table_name`)
  4. Logs de aplicaci√≥n para errores espec√≠ficos
- **Problemas comunes a verificar**:
  - Migraciones no aplicadas
  - Modelos sin herencia de `Base`
  - Campos sin valores por defecto
  - Constraints violados

## üîß **SERVICIOS DE NEGOCIO**

### **Principios de Servicios**
- **L√≥gica de Negocio**: Toda la l√≥gica compleja va en servicios
- **Transacciones**: Manejar transacciones de base de datos apropiadamente
- **Validaciones**: Validar datos antes de procesar
- **Notificaciones**: Enviar notificaciones despu√©s de operaciones exitosas
- **Logging**: Registrar operaciones importantes

### **Ejemplo de Servicio**
```python
class PackageService:
    def __init__(self, db: Session):
        self.db = db
        self.rate_service = RateService(db)
        self.notification_service = NotificationService(db)
    
    def create_package(self, package_data: PackageCreate) -> Package:
        # Validaciones
        # C√°lculos de tarifas
        # Crear en BD
        # Enviar notificaciones
        # Retornar resultado
```

---

## üìß **SISTEMA DE NOTIFICACIONES MULTICANAL**

### **Arquitectura de Notificaciones**
- **Desacoplamiento**: Las notificaciones deben ser as√≠ncronas
- **M√∫ltiples Canales**: Soporte para Email, SMS, WhatsApp
- **Fallback**: Si falla un canal, intentar otro
- **Idempotencia**: Evitar duplicados con message_id √∫nico
- **Reintentos**: Implementar reintentos exponenciales
- **Auditor√≠a**: Guardar estado en tabla notifications_log

### **Flujo de Notificaciones**
```
Evento de Negocio ‚Üí NotificationEvent ‚Üí Redis Queue ‚Üí Notification Service ‚Üí Channel Handlers
```

### **Implementaci√≥n del Sistema**
```python
from enum import Enum
from typing import Dict, Any
import redis
import json
from datetime import datetime

class NotificationChannel(Enum):
    EMAIL = "email"
    SMS = "sms"
    WHATSAPP = "whatsapp"
    PUSH = "push"

class NotificationEvent:
    """Evento de notificaci√≥n"""
    def __init__(self, user_id: str, channel: NotificationChannel, template: str, data: Dict[str, Any]):
        self.message_id = str(uuid.uuid4())
        self.user_id = user_id
        self.channel = channel
        self.template = template
        self.data = data
        self.timestamp = datetime.utcnow()
        self.retry_count = 0
        self.max_retries = 3

class NotificationService:
    """Servicio de notificaciones multicanal"""
    
    def __init__(self, db: Session, redis_client: redis.Redis):
        self.db = db
        self.redis = redis_client
        self.channel_handlers = {
            NotificationChannel.EMAIL: EmailHandler(),
            NotificationChannel.SMS: SMSHandler(),
            NotificationChannel.WHATSAPP: WhatsAppHandler()
        }
    
    def send_notification(self, event: NotificationEvent):
        """Enviar notificaci√≥n de forma as√≠ncrona"""
        # Emitir evento a la cola
        self.redis.lpush('notification_queue', json.dumps(event.__dict__))
        
        # Log del evento
        log_with_context(
            f"Notification queued: {event.message_id}",
            user_id=event.user_id,
            trace_id=event.message_id
        )
    
    def process_notification_queue(self):
        """Procesar cola de notificaciones"""
        while True:
            # Obtener evento de la cola
            event_data = self.redis.brpop('notification_queue', timeout=1)
            if not event_data:
                continue
            
            event = NotificationEvent(**json.loads(event_data[1]))
            
            try:
                # Intentar enviar por canal principal
                success = self.send_via_channel(event, event.channel)
                
                if not success and event.retry_count < event.max_retries:
                    # Reintento con backoff exponencial
                    event.retry_count += 1
                    delay = 2 ** event.retry_count
                    self.redis.lpush('notification_queue', json.dumps(event.__dict__))
                    time.sleep(delay)
                elif not success:
                    # Fallback a canal alternativo
                    self.send_fallback(event)
                
                # Registrar en auditor√≠a
                self.log_notification(event, success)
                
            except Exception as e:
                log_with_context(
                    f"Notification error: {str(e)}",
                    user_id=event.user_id,
                    trace_id=event.message_id
                )
    
    def send_via_channel(self, event: NotificationEvent, channel: NotificationChannel) -> bool:
        """Enviar notificaci√≥n por canal espec√≠fico"""
        handler = self.channel_handlers.get(channel)
        if not handler:
            return False
        
        try:
            return handler.send(event)
        except Exception as e:
            log_with_context(
                f"Channel {channel.value} failed: {str(e)}",
                user_id=event.user_id,
                trace_id=event.message_id
            )
            return False
    
    def send_fallback(self, event: NotificationEvent):
        """Enviar notificaci√≥n por canal de respaldo"""
        fallback_channels = {
            NotificationChannel.SMS: NotificationChannel.EMAIL,
            NotificationChannel.WHATSAPP: NotificationChannel.SMS,
            NotificationChannel.EMAIL: NotificationChannel.SMS
        }
        
        fallback_channel = fallback_channels.get(event.channel)
        if fallback_channel:
            self.send_via_channel(event, fallback_channel)
    
    def log_notification(self, event: NotificationEvent, success: bool):
        """Registrar notificaci√≥n en auditor√≠a"""
        notification_log = NotificationLog(
            message_id=event.message_id,
            user_id=event.user_id,
            channel=event.channel.value,
            template=event.template,
            status="sent" if success else "failed",
            retry_count=event.retry_count,
            timestamp=event.timestamp
        )
        
        self.db.add(notification_log)
        self.db.commit()

class EmailHandler:
    """Manejador de notificaciones por email"""
    
    def send(self, event: NotificationEvent) -> bool:
        # Implementar env√≠o por email
        # Usar templates Jinja2
        # Configurar SMTP
        pass

class SMSHandler:
    """Manejador de notificaciones por SMS"""
    
    def send(self, event: NotificationEvent) -> bool:
        # Implementar env√≠o por SMS
        # Integrar con Twilio o similar
        pass

class WhatsAppHandler:
    """Manejador de notificaciones por WhatsApp"""
    
    def send(self, event: NotificationEvent) -> bool:
        # Implementar env√≠o por WhatsApp
        # Integrar con API de WhatsApp Business
        pass
```

### **Modelo de Auditor√≠a**
```python
class NotificationLog(BaseModel, Base):
    __tablename__ = "notifications_log"
    
    id = Column(Integer, primary_key=True, index=True)
    message_id = Column(String(36), unique=True, nullable=False, index=True)
    user_id = Column(String(50), nullable=False, index=True)
    channel = Column(String(20), nullable=False)
    template = Column(String(100), nullable=False)
    status = Column(String(20), nullable=False)  # sent, failed, retrying
    retry_count = Column(Integer, default=0)
    error_message = Column(Text, nullable=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    sent_at = Column(DateTime, nullable=True)
    
    def __repr__(self):
        return f"<NotificationLog {self.message_id} - {self.status}>"
```

### **Templates de Notificaciones**
```python
from jinja2 import Template

# Templates centralizados
EMAIL_TEMPLATES = {
    "package_created": Template("""
    <h2>Paquete Creado Exitosamente</h2>
    <p>Hola {{ user_name }},</p>
    <p>Tu paquete con n√∫mero de seguimiento <strong>{{ tracking_number }}</strong> ha sido creado.</p>
    <p>Estado: {{ status }}</p>
    <p>Tarifa: ${{ rate }}</p>
    """),
    
    "password_reset": Template("""
    <h2>Restablecimiento de Contrase√±a</h2>
    <p>Haz clic en el siguiente enlace para restablecer tu contrase√±a:</p>
    <a href="{{ reset_url }}">Restablecer Contrase√±a</a>
    """)
}

SMS_TEMPLATES = {
    "package_created": "Tu paquete {{ tracking_number }} ha sido creado. Estado: {{ status }}. Tarifa: ${{ rate }}",
    "password_reset": "Tu c√≥digo de restablecimiento es: {{ reset_code }}"
}
```

## üõ°Ô∏è **SEGURIDAD Y VALIDACI√ìN**

### **Autenticaci√≥n y Autorizaci√≥n**
- **JWT Tokens**: Usar tokens JWT para autenticaci√≥n
- **Roles y Permisos**: Implementar sistema de roles (admin, operator, user)
- **Password Hashing**: Usar bcrypt para hashing de contrase√±as
- **Rate Limiting**: Implementar l√≠mites de rate para APIs

### **Validaci√≥n de Datos**
- **Pydantic Schemas**: Usar Pydantic para validaci√≥n de entrada
- **Validaciones Personalizadas**: Crear validadores espec√≠ficos del dominio
- **Sanitizaci√≥n**: Sanitizar datos de entrada
- **Validaciones de Negocio**: Validar reglas de negocio en servicios

### **Ejemplo de Validaci√≥n**
```python
def validate_phone_number(phone: str) -> bool:
    """Validar formato de n√∫mero de tel√©fono colombiano"""
    pattern = r'^(\+57\s?)?(3\d{2})\s?(\d{3})\s?(\d{4})$'
    return bool(re.match(pattern, phone))
```

## üê≥ **DOCKER / CONTAINERS**

### **Dockerfile**
- **Multi-stage Builds**: Usar multi-stage para optimizar tama√±o
- **Security**: Ejecutar como usuario no-root
- **Caching**: Optimizar capas para mejor caching
- **Health Checks**: Incluir health checks apropiados

### **Docker Compose**
- **Networks**: Usar redes personalizadas para aislamiento
- **Volumes**: Montar vol√∫menes para persistencia
- **Environment Variables**: Usar archivos .env para configuraci√≥n
- **Dependencies**: Definir dependencias entre servicios

## üìä **OBSERVABILIDAD AVANZADA**

### **Logging Estructurado**
- **Correlaci√≥n de Requests**: Cada petici√≥n debe tener un `trace_id` y `span_id` √∫nicos
- **Contexto de Usuario**: Incluir `user_id`, `role`, `ip_address` en logs de seguridad
- **Structured Logging**: Usar formato JSON con campos estructurados
- **Log Levels**: Usar niveles apropiados (DEBUG, INFO, WARNING, ERROR, CRITICAL)
- **Log Rotation**: Configurar rotaci√≥n autom√°tica (90 d√≠as de retenci√≥n)
- **Centralizaci√≥n**: Enviar logs a archivo centralizado con formato estructurado

### **Ejemplo de Log Estructurado**
```python
import logging
import uuid
from datetime import datetime

# Configurar logging estructurado
logging.basicConfig(
    level=logging.INFO,
    format='{"timestamp": "%(asctime)s", "level": "%(levelname)s", "trace_id": "%(trace_id)s", "user_id": "%(user_id)s", "message": "%(message)s"}',
    handlers=[
        logging.FileHandler('logs/app.log'),
        logging.StreamHandler()
    ]
)

def log_with_context(message: str, user_id: str = None, trace_id: str = None):
    """Log con contexto estructurado"""
    extra = {
        'trace_id': trace_id or str(uuid.uuid4()),
        'user_id': user_id or 'anonymous',
        'timestamp': datetime.utcnow().isoformat()
    }
    logging.info(message, extra=extra)
```

### **M√©tricas de Negocio (SLIs)**
- **Disponibilidad**: Uptime de APIs, % de respuestas 2xx vs errores
- **Latencia**: Percentiles P50, P90, P99 por endpoint
- **Uso de Recursos**: CPU, memoria, conexiones DB
- **M√©tricas de Negocio**:
  - N√∫mero de paquetes creados por hora
  - Tarifas calculadas exitosamente
  - Notificaciones enviadas vs fallidas
  - Usuarios activos por d√≠a

### **Implementaci√≥n de M√©tricas**
```python
from prometheus_client import Counter, Histogram, Gauge

# M√©tricas de negocio
packages_created = Counter('packages_created_total', 'Total packages created')
notifications_sent = Counter('notifications_sent_total', 'Total notifications sent', ['channel'])
api_request_duration = Histogram('api_request_duration_seconds', 'API request duration')
active_users = Gauge('active_users_total', 'Total active users')

# Decorador para m√©tricas autom√°ticas
def track_metrics(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = func(*args, **kwargs)
            api_request_duration.observe(time.time() - start_time)
            return result
        except Exception as e:
            # Incrementar contador de errores
            return result
    return wrapper
```

### **Health Checks Avanzados**
```python
@router.get("/health")
async def health_check():
    """Health check completo con m√©tricas"""
    health_status = {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "version": "3.1.0",
        "checks": {
            "database": check_database_connection(),
            "redis": check_redis_connection(),
            "email_service": check_email_service(),
            "disk_space": check_disk_space(),
            "memory_usage": check_memory_usage()
        }
    }
    
    # Si alg√∫n check falla, cambiar status
    if any(not check["healthy"] for check in health_status["checks"].values()):
        health_status["status"] = "unhealthy"
        return JSONResponse(status_code=503, content=health_status)
    
    return health_status
```

### **Alertas y Monitoreo**
- **Errores Cr√≠ticos**: >5% de respuestas 5xx en 5 minutos
- **Latencia**: P99 > 2s en endpoints cr√≠ticos
- **Disponibilidad DB**: Conexi√≥n fallida >3 intentos
- **Notificaciones Fallidas**: Reintentos >10% en √∫ltima hora
- **Uso de Recursos**: CPU >80% sostenido 15 minutos

### **Implementaci√≥n de Alertas**
```python
class AlertManager:
    """Gestor de alertas del sistema"""
    
    def __init__(self):
        self.alert_thresholds = {
            'error_rate': 0.05,  # 5%
            'latency_p99': 2.0,  # 2 segundos
            'cpu_usage': 0.80,   # 80%
            'notification_failure_rate': 0.10  # 10%
        }
    
    def check_error_rate(self, error_count: int, total_requests: int):
        """Verificar tasa de errores"""
        if total_requests > 0 and (error_count / total_requests) > self.alert_thresholds['error_rate']:
            self.send_alert("HIGH_ERROR_RATE", f"Error rate: {error_count/total_requests:.2%}")
    
    def send_alert(self, alert_type: str, message: str):
        """Enviar alerta"""
        alert = {
            "type": alert_type,
            "message": message,
            "timestamp": datetime.utcnow().isoformat(),
            "severity": "HIGH"
        }
        
        # Log de alerta
        logging.critical(f"ALERT: {alert}")
        
        # Enviar notificaci√≥n (email, SMS, etc.)
        self.notify_team(alert)
```

## üé® **FRONTEND / TEMPLATES**

### **HTML/Templates**
- **Semantic HTML**: Usar HTML sem√°ntico apropiado
- **Accessibility**: Seguir est√°ndares de accesibilidad (WCAG 2.1 AA)
- **Responsive Design**: Dise√±o mobile-first
- **SEO**: Optimizar para motores de b√∫squeda

### **Estructura de P√°ginas (OBLIGATORIO)**
- **Header Completo**: Todas las p√°ginas deben incluir el mismo header con navegaci√≥n completa
- **Footer Sticky**: Todas las p√°ginas deben incluir el mismo footer sticky (pegado al fondo)
- **Ancho Completo**: Tanto el header como el footer deben tener ancho completo (full-width)
- **Layout Base**: Todas las p√°ginas deben extender `components/base.html`
- **Consistencia**: Mantener la misma estructura visual en todas las p√°ginas
- **Navegaci√≥n**: Incluir navegaci√≥n completa en el sidebar
- **Responsive**: Asegurar que header y footer funcionen en m√≥viles

### **Tailwind CSS**
- **Utility Classes**: Usar clases de utilidad de Tailwind
- **Custom Components**: Crear componentes reutilizables
- **Responsive**: Usar breakpoints apropiados
- **Dark Mode**: Preparar para modo oscuro

### **HTMX**
- **Progressive Enhancement**: Mejorar funcionalidad gradualmente
- **Loading States**: Mostrar estados de carga
- **Error Handling**: Manejar errores apropiadamente
- **Validation**: Validaci√≥n del lado cliente

### **Alpine.js**
- **Reactivity**: Usar reactividad para UI din√°mica
- **State Management**: Manejar estado del componente
- **Event Handling**: Manejar eventos apropiadamente
- **Performance**: Optimizar para rendimiento

## üß™ **TESTING**

### **Unit Tests**
- **Pytest**: Usar pytest como framework de testing
- **Fixtures**: Crear fixtures reutilizables
- **Mocking**: Mockear dependencias externas
- **Coverage**: Mantener cobertura de c√≥digo alta

### **Integration Tests**
- **Database Testing**: Tests con base de datos real
- **API Testing**: Tests de endpoints completos
- **Authentication Testing**: Tests de autenticaci√≥n
- **Error Scenarios**: Tests de casos de error

### **Frontend Testing (REGLAS ESPEC√çFICAS)**
- **NO realizar pruebas visuales autom√°ticas**: El usuario realizar√° verificaci√≥n visual manual
- **NO crear scripts de testing visual**: No automatizar pruebas de apariencia o dise√±o
- **Solo crear pruebas t√©cnicas cuando se solicite**: Crear scripts de prueba √∫nicamente cuando el usuario solicite investigar problemas espec√≠ficos
- **Enfoque en debugging**: Las pruebas deben enfocarse en diagnosticar por qu√© algo no funciona, d√≥nde se carga algo, o por qu√© ocurre un comportamiento espec√≠fico
- **Documentar problemas**: Cuando se identifiquen problemas t√©cnicos, documentarlos en `TEST/reports/` con detalles de diagn√≥stico

### **Documentaci√≥n Autom√°tica de Pruebas**
- **SCRIPTS/**: Todos los scripts de automatizaci√≥n, despliegue y pruebas deben guardarse en `SCRIPTS/`
- **TEST/**: Todos los reportes, resultados y documentaci√≥n de pruebas deben guardarse en `TEST/`
- **Estructura Obligatoria**: Cada script o prueba debe documentarse con:
  - Descripci√≥n del prop√≥sito
  - Comandos de ejecuci√≥n
  - Resultados esperados
  - Dependencias requeridas
  - Fecha de creaci√≥n/actualizaci√≥n

### **Reglas de Documentaci√≥n de Scripts**
```bash
# Estructura obligatoria para scripts en SCRIPTS/
#!/bin/bash
# ========================================
# PAQUETES EL CLUB v3.0 - [Nombre del Script]
# ========================================
#
# üéØ OBJETIVO: Descripci√≥n del prop√≥sito
# üìÖ FECHA: YYYY-MM-DD
# üë§ AUTOR: [Nombre del desarrollador]
# üîÑ VERSI√ìN: [Versi√≥n del script]
#
# üìã USO:
#   ./script-name.sh [par√°metros]
#
# üìä RESULTADOS:
#   - Archivo de log: logs/script-name.log
#   - Reporte: TEST/reports/script-name-report.md
#   - Datos: TEST/results/script-name/
#
# ‚ö†Ô∏è DEPENDENCIAS:
#   - [Lista de dependencias]
#
# ========================================
```

### **Reglas de Documentaci√≥n de Pruebas**
```markdown
# Estructura obligatoria para reportes en TEST/reports/
# ========================================
# PAQUETES EL CLUB v3.0 - [Nombre de la Prueba]
# ========================================
#
# üéØ OBJETIVO: Descripci√≥n del objetivo de la prueba
# üìÖ FECHA: YYYY-MM-DD HH:MM:SS
# üë§ EJECUTOR: [Nombre del ejecutor]
# üîÑ VERSI√ìN: [Versi√≥n del sistema probado]
#
# üìä RESULTADOS:
#   - Estado: ‚úÖ PASS / ‚ùå FAIL
#   - Tiempo de ejecuci√≥n: XX.XX segundos
#   - Errores encontrados: X
#   - Advertencias: X
#
# üîç DETALLES:
#   [Comandos ejecutados y resultados]
#
# üìà M√âTRICAS:
#   [M√©tricas de rendimiento y calidad]
#
# ‚úÖ CONCLUSIONES:
#   [Resumen y recomendaciones]
#
# ========================================
```

### **Ejemplo de Test**
```python
def test_create_package_success(db_session):
    """Test crear paquete exitosamente"""
    package_service = PackageService(db_session)
    package_data = PackageCreate(...)
    
    result = package_service.create_package(package_data)
    
    assert result.tracking_number.startswith("PAP")
    assert result.status == PackageStatus.ANUNCIADO
```

## üìù **DOCUMENTACI√ìN**

### **C√≥digo**
- **Docstrings**: Documentar todas las funciones p√∫blicas
- **Type Hints**: Usar type hints para documentar tipos
- **Comments**: Comentar l√≥gica compleja
- **README**: Mantener README actualizado

### **API Documentation**
- **OpenAPI/Swagger**: Documentaci√≥n autom√°tica con FastAPI
- **Examples**: Incluir ejemplos de uso
- **Error Responses**: Documentar respuestas de error
- **Authentication**: Documentar autenticaci√≥n

## üöÄ **DEPLOYMENT**

### **Environment Configuration**
- **Environment Variables**: Usar variables de entorno para configuraci√≥n
- **Secrets Management**: Manejar secretos apropiadamente
- **Configuration Validation**: Validar configuraci√≥n al inicio
- **Feature Flags**: Usar feature flags para funcionalidades

### **CI/CD**
- **Automated Testing**: Tests autom√°ticos en pipeline
- **Code Quality**: Checks de calidad de c√≥digo
- **Security Scanning**: Escaneo de vulnerabilidades
- **Automated Deployment**: Despliegue autom√°tico

## üîç **DEBUGGING Y TROUBLESHOOTING**

### **Logging**
- **Structured Logs**: Logs estructurados para f√°cil parsing
- **Context Information**: Incluir contexto relevante
- **Error Tracking**: Integrar con sistema de tracking de errores
- **Performance Logging**: Log de m√©tricas de rendimiento

### **Development Tools**
- **Hot Reload**: Configurar hot reload para desarrollo
- **Debug Mode**: Modo debug con informaci√≥n detallada
- **Database Tools**: Herramientas para inspeccionar BD
- **API Testing**: Herramientas para probar APIs

## üìã **CHECKLIST DE CALIDAD**

### **Antes de Commit**
- [ ] Tests pasan
- [ ] Linting sin errores
- [ ] Type checking sin errores
- [ ] Documentaci√≥n actualizada
- [ ] Logs apropiados agregados
- [ ] Manejo de errores implementado

### **Antes de Deploy**
- [ ] Tests de integraci√≥n pasan
- [ ] Performance tests pasan
- [ ] Security scan limpio
- [ ] Configuraci√≥n validada
- [ ] Backup configurado
- [ ] Monitoring configurado

---

## üö´ **REGLAS DE INTERVENCI√ìN Y MODIFICACI√ìN**

### **Soluciones Temporales**
- **SOLO crear soluciones temporales cuando el usuario lo solicite expl√≠citamente**
- **NO implementar parches o workarounds sin autorizaci√≥n**
- **Documentar todas las modificaciones temporales con prop√≥sito y fecha de eliminaci√≥n**
- **Crear plan de limpieza para remover c√≥digo temporal**

### **Diagn√≥stico y An√°lisis**
- **Consultar logs antes de modificar c√≥digo**
- **Proponer diagn√≥stico antes de implementar cambios**
- **Usar scripts de testing existentes para identificar problemas**
- **Analizar el contexto completo antes de sugerir modificaciones**

### **Confirmaci√≥n y Comunicaci√≥n**
- **Solicitar confirmaci√≥n antes de cambios no solicitados**
- **Explicar brevemente el prop√≥sito de cada modificaci√≥n**
- **Informar sobre el impacto potencial de los cambios**
- **Proporcionar alternativas cuando sea apropiado**

### **Consistencia y Estilo**
- **Mantener SIEMPRE consistencia con el estilo del proyecto**
- **Seguir las convenciones establecidas en el c√≥digo existente**
- **Respetar la arquitectura y patrones del proyecto**
- **No introducir cambios que rompan la coherencia del sistema**

## üì± **ORIENTACI√ìN MOBILE-FIRST**

### **Dise√±o Responsivo**
- **El proyecto es orientado a Mobile first**
- **Dise√±ar primero para dispositivos m√≥viles (320px - 768px)**
- **Adaptar posteriormente para tablets (768px - 1024px)**
- **Optimizar finalmente para desktop (1024px+)**

### **Implementaci√≥n Frontend**
- **Usar breakpoints de Tailwind CSS apropiados para mobile-first**
- **Priorizar la experiencia de usuario en dispositivos m√≥viles**
- **Optimizar formularios y navegaci√≥n para touch**
- **Asegurar que todos los elementos sean accesibles en pantallas peque√±as**

### **Testing Mobile**
- **Probar funcionalidad en dispositivos m√≥viles reales**
- **Verificar responsive design en diferentes tama√±os de pantalla**
- **Validar performance en conexiones m√≥viles**
- **Asegurar accesibilidad en dispositivos m√≥viles**

---

## üéØ **PRIORIDADES DE DESARROLLO**

1. **Funcionalidad Core**: Paquetes, clientes, tarifas
2. **Autenticaci√≥n**: Sistema de usuarios y roles
3. **Notificaciones**: Email y SMS
4. **Dashboard**: M√©tricas y reportes
5. **Optimizaci√≥n**: Performance y escalabilidad
6. **Seguridad**: Hardening y auditor√≠a
7. **UX/UI**: Mejoras de interfaz
8. **Integraci√≥n**: APIs externas

---

## üìÅ **ORGANIZACI√ìN AUTOM√ÅTICA DE ARCHIVOS**

### **Reglas de Organizaci√≥n Autom√°tica**
- **SIEMPRE organizar archivos autom√°ticamente** seg√∫n su tipo y prop√≥sito
- **Detectar patrones de nombres** y mover archivos a ubicaciones correctas
- **Mantener estructura limpia** sin intervenci√≥n manual
- **Generar reportes** de organizaci√≥n autom√°tica

### **Patrones de Archivos y Ubicaciones**

#### **üìÇ Tests ‚Üí `code/TEST/`**
```
Patrones:
- test_*.py
- *_test.py
- test_*.html
- *_test.html
- test_*.sh
- *_test.sh
- test_*.js
- *_test.js

Ejemplos:
- test_auth_system.py ‚Üí code/TEST/
- email_test.py ‚Üí code/TEST/
- test_focus.html ‚Üí code/TEST/
- api_test.sh ‚Üí code/TEST/
```

#### **üìÇ Scripts ‚Üí `code/SCRIPTS/`**
```
Patrones:
- *.sh
- *_script.py
- setup_*.py
- deploy_*.py
- *_runner.py
- *_automation.py
- *_tool.py
- *_helper.py

Ejemplos:
- deploy.sh ‚Üí code/SCRIPTS/
- setup_auth.py ‚Üí code/SCRIPTS/
- email_script.py ‚Üí code/SCRIPTS/
- backup_runner.py ‚Üí code/SCRIPTS/
```

#### **üìÇ Deployment Docs ‚Üí `docs/deployment-docs/`**
```
Patrones:
- *_GUIDE.md
- *_COMPLETADO.md
- *_LIGHTSAIL.md
- *_DEPLOYMENT.md
- *_AWS.md
- *_PRODUCTION.md
- *_STAGING.md
- *_ENVIRONMENT.md

Ejemplos:
- AWS_LIGHTSAIL_GUIDE.md ‚Üí docs/deployment-docs/
- DEPLOYMENT_COMPLETADO.md ‚Üí docs/deployment-docs/
- PRODUCTION_SETUP.md ‚Üí docs/deployment-docs/
```

#### **üìÇ General Docs ‚Üí `docs/`**
```
Patrones:
- *_FIXES.md
- *_SUMMARY.md
- *_ANALISIS.md
- *_SOLUTION.md
- *_REPORT.md
- *_DOCUMENTATION.md
- *_README.md
- *_CHANGELOG.md

Ejemplos:
- AUTH_SYSTEM_FIXES.md ‚Üí docs/
- EMAIL_SYSTEM_FIXES.md ‚Üí docs/
- MIGRATION_SUMMARY.md ‚Üí docs/
```

#### **üìÇ Config Files ‚Üí `code/config/`**
```
Patrones:
- *.config
- *.conf
- env_*
- config_*
- settings_*
- *_config.py
- *_settings.py

Ejemplos:
- nginx.conf ‚Üí code/config/
- env.production ‚Üí code/config/
- app_config.py ‚Üí code/config/
```

### **Script de Organizaci√≥n Autom√°tica**

#### **Crear autom√°ticamente el script de organizaci√≥n**
```python
# Ubicaci√≥n: code/SCRIPTS/auto_organize_files.py
# Prop√≥sito: Organizar archivos autom√°ticamente seg√∫n patrones
# Ejecuci√≥n: Autom√°tica al crear archivos o manualmente
```

#### **Reglas de Ejecuci√≥n**
- **Ejecutar autom√°ticamente** cuando se detecte un archivo fuera de lugar
- **Verificar estructura** cada vez que se cree un nuevo archivo
- **Generar reportes** de organizaci√≥n en `code/TEST/reports/`
- **Mantener logs** de organizaci√≥n en `code/logs/`

### **Implementaci√≥n de Organizaci√≥n**

#### **Detecci√≥n Autom√°tica**
```python
# Detectar archivos que necesitan organizaci√≥n
def detect_files_for_organization():
    patterns = {
        'tests': ['test_*.py', '*_test.py', 'test_*.html'],
        'scripts': ['*.sh', '*_script.py', 'setup_*.py'],
        'deployment_docs': ['*_GUIDE.md', '*_COMPLETADO.md'],
        'general_docs': ['*_FIXES.md', '*_SUMMARY.md'],
        'config': ['*.config', 'env_*', 'config_*.py']
    }
    return patterns
```

#### **Mover Archivos Autom√°ticamente**
```python
# Mover archivos a ubicaciones correctas
def organize_files():
    for file_path in detect_misplaced_files():
        target_dir = get_target_directory(file_path)
        move_file(file_path, target_dir)
        log_organization(file_path, target_dir)
```

#### **Generar Reportes**
```python
# Generar reporte de organizaci√≥n
def generate_organization_report():
    report = {
        'date': datetime.now(),
        'files_moved': moved_files,
        'structure_verified': True,
        'recommendations': []
    }
    save_report('code/TEST/reports/file_organization_report.md', report)
```

### **Reglas de Validaci√≥n**

#### **Antes de Mover Archivos**
- **Verificar que el archivo no est√© en uso**
- **Confirmar que el directorio destino existe**
- **Validar que no haya conflictos de nombres**
- **Crear directorios si no existen**

#### **Despu√©s de Mover Archivos**
- **Actualizar referencias en el c√≥digo**
- **Regenerar documentaci√≥n si es necesario**
- **Notificar cambios importantes**
- **Mantener historial de movimientos**

### **Comandos de Organizaci√≥n**

#### **Organizaci√≥n Manual**
```bash
# Ejecutar organizaci√≥n manual
cd code/SCRIPTS/
python3 auto_organize_files.py

# Verificar estructura
python3 auto_organize_files.py --check

# Generar reporte
python3 auto_organize_files.py --report
```

#### **Organizaci√≥n Autom√°tica**
```bash
# Configurar hook de pre-commit
# Configurar watcher de archivos
# Configurar trigger en creaci√≥n de archivos
```

### **Mantenimiento de Organizaci√≥n**

#### **Verificaci√≥n Peri√≥dica**
- **Revisar estructura semanalmente**
- **Limpiar archivos temporales**
- **Actualizar patrones seg√∫n necesidades**
- **Optimizar reglas de organizaci√≥n**

#### **Documentaci√≥n de Cambios**
- **Registrar todos los movimientos de archivos**
- **Mantener historial de organizaci√≥n**
- **Documentar patrones nuevos**
- **Actualizar reglas seg√∫n evoluci√≥n del proyecto**

---

## ‚ö†Ô∏è **LIMITACIONES Y AJUSTES ESPEC√çFICOS**

### **Puntos NO Aplicables para este Proyecto**

#### **1. Trazas Distribuidas Complejas**
- **Raz√≥n**: Proyecto peque√±o sin microservicios
- **Alternativa**: Logging estructurado con trace_id es suficiente
- **Implementaci√≥n**: Usar UUID √∫nico por request

#### **2. Sistemas de Logging Enterprise**
- **Raz√≥n**: No se requiere ELK Stack o sistemas complejos
- **Alternativa**: Logging a archivos con rotaci√≥n autom√°tica
- **Implementaci√≥n**: Logs estructurados en JSON

#### **3. Colas de Mensajer√≠a Complejas**
- **Raz√≥n**: Redis es suficiente para el volumen actual
- **Alternativa**: Redis Lists para colas simples
- **Implementaci√≥n**: Redis como broker de mensajes

#### **4. M√∫ltiples Proveedores de Notificaciones**
- **Raz√≥n**: Un proveedor por canal es suficiente
- **Alternativa**: Configuraci√≥n simple con fallback
- **Implementaci√≥n**: SMTP para email, Twilio para SMS

### **Ajustes Recomendados para el Proyecto**

#### **1. Observabilidad Simplificada**
```python
# En lugar de OpenTelemetry, usar logging estructurado
def log_request(request_id: str, user_id: str, action: str, status: str):
    log_data = {
        "request_id": request_id,
        "user_id": user_id,
        "action": action,
        "status": status,
        "timestamp": datetime.utcnow().isoformat()
    }
    logging.info(json.dumps(log_data))
```

#### **2. M√©tricas B√°sicas**
```python
# M√©tricas simples sin Prometheus complejo
class SimpleMetrics:
    def __init__(self):
        self.counters = {}
    
    def increment(self, metric_name: str):
        self.counters[metric_name] = self.counters.get(metric_name, 0) + 1
    
    def get_metrics(self):
        return self.counters
```

#### **3. Notificaciones Simplificadas**
```python
# Sistema de notificaciones con Redis simple
class SimpleNotificationService:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    def send_email(self, to: str, subject: str, body: str):
        # Env√≠o directo por SMTP
        pass
    
    def send_sms(self, to: str, message: str):
        # Env√≠o directo por Twilio
        pass
```

### **Configuraci√≥n Recomendada**

#### **1. Logging**
```python
# Configuraci√≥n de logging para el proyecto
LOGGING_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "structured": {
            "format": '{"timestamp": "%(asctime)s", "level": "%(levelname)s", "message": "%(message)s", "trace_id": "%(trace_id)s"}'
        }
    },
    "handlers": {
        "file": {
            "class": "logging.handlers.RotatingFileHandler",
            "filename": "logs/app.log",
            "maxBytes": 10485760,  # 10MB
            "backupCount": 5,
            "formatter": "structured"
        }
    },
    "root": {
        "handlers": ["file"],
        "level": "INFO"
    }
}
```

#### **2. M√©tricas**
```python
# M√©tricas b√°sicas para el proyecto
METRICS_CONFIG = {
    "enabled": True,
    "interval": 60,  # segundos
    "metrics_file": "logs/metrics.json",
    "retention_days": 30
}
```

#### **3. Alertas**
```python
# Alertas b√°sicas para el proyecto
ALERTS_CONFIG = {
    "error_rate_threshold": 0.05,  # 5%
    "latency_threshold": 2.0,      # 2 segundos
    "notification_channels": ["email", "sms"],
    "admin_email": "admin@papyrus.com.co"
}
```

---

## üìã **CHECKLIST DE IMPLEMENTACI√ìN**

### **‚úÖ Observabilidad B√°sica**
- [ ] Logging estructurado con trace_id
- [ ] M√©tricas de negocio b√°sicas
- [ ] Health checks completos
- [ ] Alertas por email/SMS

### **‚úÖ Notificaciones Multicanal**
- [ ] Sistema as√≠ncrono con Redis
- [ ] Manejadores por canal (Email, SMS)
- [ ] Sistema de fallback
- [ ] Auditor√≠a de notificaciones

### **‚úÖ Monitoreo**
- [ ] M√©tricas de disponibilidad
- [ ] M√©tricas de latencia
- [ ] M√©tricas de negocio
- [ ] Sistema de alertas

---

**√öltima actualizaci√≥n**: Agosto 2025  
**Versi√≥n**: 3.1.0  
**Mantenido por**: Equipo de Desarrollo PAQUETES EL CLUB
